import java.io.BufferedReader;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.net.URL;
import java.util.Arrays;
import java.util.ResourceBundle;
import javafx.beans.property.ReadOnlyStringWrapper;
import javafx.collections.FXCollections;
import javafx.collections.ObservableList;
import javafx.event.ActionEvent;
import javafx.fxml.FXML;
import javafx.fxml.Initializable;
import javafx.scene.chart.PieChart;
import javafx.scene.chart.StackedBarChart;
import javafx.scene.control.Label;
import javafx.scene.control.SplitPane;
import javafx.scene.control.TableCell;
import javafx.scene.control.TableColumn;
import javafx.scene.control.TableView;
import javafx.scene.control.cell.PropertyValueFactory;
import javafx.scene.input.MouseEvent;
import javafx.scene.layout.AnchorPane;
import javafx.scene.paint.Color;
import javafx.scene.text.Font;
import javafx.scene.text.Text;
import javafx.scene.text.TextFlow;
import java.util.Random;
import java.util.logging.Level;
import java.util.logging.Logger;
import javafx.application.Platform;
import javafx.concurrent.Task;
import javafx.scene.chart.CategoryAxis;
import javafx.scene.chart.NumberAxis;
import javafx.scene.chart.XYChart;
import javafx.scene.control.ProgressIndicator;
import weka.classifiers.evaluation.Evaluation;
import weka.classifiers.trees.RandomForest;
import weka.core.Instances;
import weka.core.converters.ConverterUtils.DataSource;

/**
 * FXML Controller class
 * Control l'interface graphique et tous ses composents
 * @author Oussama, Ilyess
 */
public class InterfaceController implements Initializable {
    
    @FXML
    AnchorPane mainAnchor, overallPane, dataAnchor, dataAnchorClassif;
    @FXML
    SplitPane splitPane;
    @FXML
    TableView<MatchPrediction> tableView;
    @FXML
    TableColumn<MatchPrediction, String> number, actual, predicted, error, prediction;
    @FXML
    TableView<String> statTableView;
    @FXML
    TableColumn<String, String> statColumn;
    @FXML
    PieChart charts;
    @FXML
    StackedBarChart<String, Number> stackedBarChart;
    @FXML
    CategoryAxis xAxis;
    @FXML
    NumberAxis yAxis;
    @FXML
    ProgressIndicator bar;
    @FXML
    TextFlow textFlow, textFlowRes;
    
    Text text1, textModel;
    double nbrErrors, nbrLines, nbrCorrect;
    Label caption = new Label("");
    
    private final ObservableList<MatchPrediction> matchPredictionModels = FXCollections.observableArrayList();
    private final ObservableList<String> stats = FXCollections.observableArrayList();
    
    /**
     * Fills the Pie chart with predicted result
     */
    private void fillPieChart(){
        double wrong = nbrErrors / nbrLines * 100.0;
        double correct = nbrCorrect / nbrLines * 100.0;
        ObservableList<PieChart.Data> pieChartData =
            FXCollections.observableArrayList(
            new PieChart.Data("Wrong Prediction", wrong),
            new PieChart.Data("Correct Prediction", correct));
        charts.setData(pieChartData);
        
        caption.setTextFill(Color.GREEN);
        caption.setStyle("-fx-font: 24 arial;");
        charts.getData().forEach((data) -> {
            data.getNode().addEventHandler(MouseEvent.MOUSE_PRESSED, (MouseEvent e) -> {
                caption.setLayoutX(e.getSceneX());
                caption.setLayoutY(e.getSceneY());
                caption.setText(String.valueOf(data.getPieValue()) + "%");
            });
        });
        
        text1.setText("Correct Prediction percentage : " + correct + "%");
        text1.setFill(Color.GREEN); 
        text1.setFont(Font.font("Verdana", 20));
        
    }
    
    /**
     * Fills the table View with the predicted matches result
     */
    private void fillTableView(){
        number.setCellValueFactory(new PropertyValueFactory<>("number"));
        actual.setCellValueFactory(new PropertyValueFactory<>("actual"));
        predicted.setCellValueFactory(new PropertyValueFactory<>("predicted"));
        error.setCellValueFactory(new PropertyValueFactory<>("error"));
        prediction.setCellValueFactory(new PropertyValueFactory<>("prediction"));
        
        error.setCellFactory((TableColumn<MatchPrediction, String> param) -> new TableCell<MatchPrediction, String>() {
            @Override
            public void updateItem(String item, boolean empty) {
                super.updateItem(item, empty);
                if (!isEmpty()) {
                    if(item.contains("+")){
                        this.setTextFill(Color.RED);
                    }
                    setText(item);
                }
            }
        });
        tableView.setItems(matchPredictionModels);
    }
    
    /**
     * Parses a CSV file generated by our prediction algorithm
     * @param event 
     */
    @FXML
    private void parseResult(ActionEvent event) {
        nbrErrors = 0;
        nbrCorrect = 0;
        nbrLines = -1;
        matchPredictionModels.clear();
        String csvFile = "src/ResultatPr√©diction.csv";
        BufferedReader br = null;
        String line;
        String[] ligne = new String[0];
        try {
            br = new BufferedReader(new FileReader(csvFile));
            while ((line = br.readLine()) != null) {
                ligne = line.split(",");
                if(nbrLines != -1){
                    matchPredictionModels.add(new MatchPrediction(Integer.parseInt(ligne[0]), ligne[1],
                        ligne[2], ligne[3], Double.parseDouble(ligne[4])));
                    if("+".equals(ligne[3])){
                        nbrErrors++;
                    }else nbrCorrect++;
                }
                nbrLines++;
            }
        } catch (FileNotFoundException e) {
            System.out.println("File not found");
        }catch(NumberFormatException e){ 
            //System.out.println(ligne[0]+","+ ligne[1] +","+ligne[2]+","+ ligne[3]+","+ ligne[4]);
            System.out.println(nbrLines);
        }catch (IOException e) {
            System.out.println("IOException");
        } finally {
            if (br != null) {
                try {
                    br.close();
                } catch (IOException e) {
                    System.out.println("Close error");
                }
            }
        }

        /*-------------------------PieChart-TabeleView-------------------------*/
        
        fillTableView();
        fillPieChart();
        
        /*-------------------------PieChart-Tableview-------------------------*/
    }
    
    @FXML
    private void loadDataSet(ActionEvent event) {
        
    }
    
    @FXML
    private void createModel(ActionEvent event) {
        bar.setVisible(true);
        Task task = new Task<Void>() {
            @Override 
            public Void call() {
                int numFolds = 10;
                DataSource source;
                ClassDetails cd1, cd2;
                try {
                    source = new DataSource("src/Csv/Oussama.csv");
                    Instances data = source.getDataSet();
                    // setting class attribute if the data format does not provide this information
                    // For example, the XRFF format saves the class attribute information as well
                    if (data.classIndex() == -1) data.setClassIndex(data.numAttributes() - 1);
                    //System.out.println(data);
                    data.setClassIndex(data.numAttributes() - 1);
                    RandomForest rf = new RandomForest();
                    rf.setNumFeatures(0);
                    rf.setBagSizePercent(100);
                    rf.setNumExecutionSlots(1);
                    rf.setMaxDepth(0);
                    rf.setNumDecimalPlaces(2);
                    
                    //   rf.buildClassifier(trainData);
                    Evaluation evaluation = new Evaluation(data);
                    evaluation.crossValidateModel(rf, data, numFolds, new Random(1));
                    
                    cd1 = new ClassDetails(evaluation.precision(0), evaluation.recall(0), evaluation.fMeasure(0));
                    cd2 = new ClassDetails(evaluation.precision(1), evaluation.recall(1), evaluation.fMeasure(1));
                    Platform.runLater(() -> {
                        try {
                            textModel.setText(evaluation.toSummaryString("\nResults\n======\n", true) +
                                "\n" + evaluation.toClassDetailsString() +
                                "\n" + "Results For Class -1- " +
                                        "\n" + "Precision=  " + cd1.getPrecision() +
                                "\n" + "Recall=  " + cd1.getRecall() +
                                "\n" + "F-measure=  " + cd1.getF_measure() +
                                "\n" + "Results For Class -2- " +
                                        "\n" + "Precision=  " + cd2.getPrecision() +
                                "\n" + "Recall=  " + cd2.getRecall() +
                                "\n" + "F-measure=  " + cd2.getF_measure());
                        }catch (Exception ex) {
                            Logger.getLogger(InterfaceController.class.getName()).log(Level.SEVERE, null, ex);
                        }
                        textModel.setFill(Color.BLACK);
                        textModel.setFont(Font.font("Verdana", 12));
                        
                        xAxis.setCategories(FXCollections.<String>observableArrayList(Arrays.asList
                            ("Precision", "Recall", "F-Measure")));
                        xAxis.setLabel("Category");
                        yAxis.setLabel("Percentage (in %)");
                        
                        stackedBarChart.setTitle("Historic Percentage (Precision, Recall and F-Measure)");
                        XYChart.Series<String, Number> series1 = new XYChart.Series<>();
                        series1.setName("Class-1-");
                        series1.getData().add(new XYChart.Data<>("Precision", cd1.getPrecision() * 100)); 
                        series1.getData().add(new XYChart.Data<>("Recall", cd1.getRecall() * 100)); 
                        series1.getData().add(new XYChart.Data<>("F-Measure", cd1.getF_measure() * 100));

                        XYChart.Series<String, Number> series2 = new XYChart.Series<>();
                        series2.setName("Class-2-");
                        series2.getData().add(new XYChart.Data<>("Precision", Math.abs(cd2.getPrecision() - cd1.getPrecision()) * 100)); 
                        series2.getData().add(new XYChart.Data<>("Recall", Math.abs(cd2.getRecall() - cd1.getRecall()) * 100));
                        series2.getData().add(new XYChart.Data<>("F-Measure", Math.abs(cd2.getF_measure() - cd1.getF_measure()) * 100));

                        //stackedBarChart.getData().addAll(series1, series2);
                        ObservableList<XYChart.Series<String, Number>> ob = FXCollections.observableArrayList();
                        ob.add(series1);
                        ob.add(series2);
                        stackedBarChart.setData(ob);
                    });
                
                } catch (Exception ex) {
                    Logger.getLogger(InterfaceController.class.getName()).log(Level.SEVERE, null, ex);
                }
                succeeded();
                bar.setVisible(false);
                return null;
            }
        };
        bar.progressProperty().bind(task.progressProperty());
        new Thread(task).start();
        
    }
    
    private void fillStats(){
        File f= new File("src/Csv/NewEnsemble.csv");
        Statistique stat = new Statistique(f);
        
        stats.add(stat.stat1(32));
        stats.add(stat.stat2(4));
        stats.add(stat.stat3(4));
        String[] tmp = stat.stat4(33, 0.50);
        stats.add(tmp[0]);
        stats.add(tmp[1]);
        stats.add(tmp[2]);
        stats.add(stat.stat5());
        stats.add(stat.stat7());
        stats.add(stat.stat8());
        tmp = stat.stat9();
        stats.add(tmp[0]);
        stats.add(tmp[1]);
        stats.add(tmp[2]);
        tmp = stat.stat10();
        stats.add(tmp[0]);
        stats.add(tmp[1]);
        stats.add(tmp[2]);
        
        statColumn.setCellValueFactory(cellData -> {
            return new ReadOnlyStringWrapper(cellData.getValue());
        });
        statTableView.setItems(stats);
    }
    
    @Override
    public void initialize(URL url, ResourceBundle rb) {
        text1 = new Text();
        textModel = new Text();
        textFlow.getChildren().add(text1);
        textFlowRes.getChildren().add(textModel);
        overallPane.getChildren().add(caption);
        
        fillStats();
        /*PauseTransition delay = new PauseTransition(Duration.millis(1000));
        delay.setOnFinished(event -> {
        //code here
        } );
        delay.play();
         */
    }    
    
}
